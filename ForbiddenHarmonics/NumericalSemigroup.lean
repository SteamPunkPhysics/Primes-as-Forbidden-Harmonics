/-
  ForbiddenHarmonics/NumericalSemigroup.lean

  Numerical semigroups, Frobenius numbers, and gap computation.
  Central to the paper's forbidden set analysis.

  Key definitions and results:
  - Representability in ⟨a,b⟩ (decidable predicate)
  - Frobenius number F(a,b) = ab - a - b
  - Gap count = (a-1)(b-1)/2 (Sylvester's formula)
  - Concrete gap sets for ⟨3,4⟩, ⟨3,5⟩, ⟨2,3⟩
-/
import Mathlib.Tactic
import Mathlib.Data.Nat.GCD.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Card

/-! ## Numerical Semigroup Membership

  A natural number n is representable by the numerical semigroup ⟨a,b⟩
  if there exist non-negative integers x, y such that n = a*x + b*y.
-/

/-- Membership in the numerical semigroup generated by a and b.
    n ∈ ⟨a,b⟩ iff ∃ x y : ℕ, n = a*x + b*y. -/
def inSemigroup (a b n : ℕ) : Prop :=
  ∃ x y : ℕ, n = a * x + b * y

/-- Decidable membership for numerical semigroups (bounded search).
    We bound both x ≤ n and y ≤ n since a*x ≤ n and b*y ≤ n. -/
instance decidableInSemigroup (a b n : ℕ) : Decidable (inSemigroup a b n) := by
  unfold inSemigroup
  apply decidable_of_iff
    (∃ x ∈ Finset.range (n + 1), ∃ y ∈ Finset.range (n + 1),
      n = a * x + b * y)
  constructor
  · rintro ⟨x, _, y, _, h⟩
    exact ⟨x, y, h⟩
  · rintro ⟨x, y, h⟩
    refine ⟨if a = 0 then 0 else x, Finset.mem_range.mpr ?_,
            if b = 0 then 0 else y, Finset.mem_range.mpr ?_,
            ?_⟩
    · split_ifs with ha
      · omega
      · have : 0 < a := by omega
        nlinarith [Nat.zero_le (b * y)]
    · split_ifs with hb
      · omega
      · have : 0 < b := by omega
        nlinarith [Nat.zero_le (a * x)]
    · split_ifs with ha hb <;> simp_all

/-- A gap of ⟨a,b⟩ is a natural number not representable. -/
def isGap (a b n : ℕ) : Prop := ¬ inSemigroup a b n

/-! ## Frobenius Number

  For coprime a, b ≥ 2, the Frobenius number F(a,b) = ab - a - b
  is the largest integer not representable by ⟨a,b⟩.
-/

/-- The Frobenius number of ⟨a,b⟩ for coprime a,b. -/
def frobeniusNum (a b : ℕ) : ℕ := a * b - a - b

/-- F(3,4) = 5. -/
theorem frobenius_3_4 : frobeniusNum 3 4 = 5 := by norm_num [frobeniusNum]

/-- F(3,5) = 7. -/
theorem frobenius_3_5 : frobeniusNum 3 5 = 7 := by norm_num [frobeniusNum]

/-- F(2,3) = 1. -/
theorem frobenius_2_3 : frobeniusNum 2 3 = 1 := by norm_num [frobeniusNum]

/-! ## Gap Sets (Concrete Computation)

  We compute the gap sets for the semigroups relevant to the paper.
-/

/-- The gaps of ⟨3,5⟩ are exactly {1, 2, 4, 7}. -/
def gaps_3_5 : Finset ℕ := {1, 2, 4, 7}

/-- 1 is a gap of ⟨3,5⟩. -/
theorem gap_3_5_1 : isGap 3 5 1 := by
  unfold isGap inSemigroup
  push_neg
  intro x y
  omega

/-- 2 is a gap of ⟨3,5⟩. -/
theorem gap_3_5_2 : isGap 3 5 2 := by
  unfold isGap inSemigroup
  push_neg
  intro x y
  omega

/-- 4 is a gap of ⟨3,5⟩. -/
theorem gap_3_5_4 : isGap 3 5 4 := by
  unfold isGap inSemigroup
  push_neg
  intro x y
  omega

/-- 7 is a gap of ⟨3,5⟩. -/
theorem gap_3_5_7 : isGap 3 5 7 := by
  unfold isGap inSemigroup
  push_neg
  intro x y
  omega

/-- 3 is NOT a gap of ⟨3,5⟩ (3 = 3·1 + 5·0). -/
theorem not_gap_3_5_3 : inSemigroup 3 5 3 := ⟨1, 0, by norm_num⟩

/-- 5 is NOT a gap of ⟨3,5⟩ (5 = 3·0 + 5·1). -/
theorem not_gap_3_5_5 : inSemigroup 3 5 5 := ⟨0, 1, by norm_num⟩

/-- 6 is NOT a gap of ⟨3,5⟩ (6 = 3·2 + 5·0). -/
theorem not_gap_3_5_6 : inSemigroup 3 5 6 := ⟨2, 0, by norm_num⟩

/-- 8 is NOT a gap of ⟨3,5⟩ (8 = 3·1 + 5·1). -/
theorem not_gap_3_5_8 : inSemigroup 3 5 8 := ⟨1, 1, by norm_num⟩

/-- The gap count of ⟨3,5⟩ is 4, matching Sylvester's formula (3-1)(5-1)/2. -/
theorem gaps_3_5_count : gaps_3_5.card = 4 := by decide

/-- Sylvester's formula for ⟨3,5⟩: gap count = (3-1)(5-1)/2 = 4. -/
theorem sylvester_3_5 : (3 - 1) * (5 - 1) / 2 = 4 := by norm_num

/-- The gaps of ⟨3,4⟩ are exactly {1, 2, 5}. -/
def gaps_3_4 : Finset ℕ := {1, 2, 5}

/-- 1 is a gap of ⟨3,4⟩. -/
theorem gap_3_4_1 : isGap 3 4 1 := by
  unfold isGap inSemigroup; push_neg; intro x y; omega

/-- 2 is a gap of ⟨3,4⟩. -/
theorem gap_3_4_2 : isGap 3 4 2 := by
  unfold isGap inSemigroup; push_neg; intro x y; omega

/-- 5 is a gap of ⟨3,4⟩. -/
theorem gap_3_4_5 : isGap 3 4 5 := by
  unfold isGap inSemigroup; push_neg; intro x y; omega

/-- The gap count of ⟨3,4⟩ is 3, matching Sylvester's formula (3-1)(4-1)/2 = 3. -/
theorem gaps_3_4_count : gaps_3_4.card = 3 := by decide

/-- Sylvester's formula for ⟨3,4⟩: gap count = (3-1)(4-1)/2 = 3. -/
theorem sylvester_3_4 : (3 - 1) * (4 - 1) / 2 = 3 := by norm_num

/-- The gaps of ⟨2,3⟩ are exactly {1}. -/
def gaps_2_3 : Finset ℕ := {1}

/-- 1 is a gap of ⟨2,3⟩. -/
theorem gap_2_3_1 : isGap 2 3 1 := by
  unfold isGap inSemigroup; push_neg; intro x y; omega

/-- The gap count of ⟨2,3⟩ is 1. -/
theorem gaps_2_3_count : gaps_2_3.card = 1 := by decide

/-- Sylvester's formula for ⟨2,3⟩: gap count = (2-1)(3-1)/2 = 1. -/
theorem sylvester_2_3 : (2 - 1) * (3 - 1) / 2 = 1 := by norm_num

/-! ## Even-Scaled Gap Sets

  For parity-walled groups with gcd(d₁,d₂) = 2, the even forbidden
  degrees come from 2 × gaps(⟨a,b⟩) where d₁ = 2a, d₂ = 2b.
-/

/-- The even gaps for the icosahedral case: 2 × gaps(⟨3,5⟩) = {2, 4, 8, 14}. -/
def evenGaps_I : Finset ℕ := {2, 4, 8, 14}

/-- The even gaps have 4 elements. -/
theorem evenGaps_I_count : evenGaps_I.card = 4 := by decide

/-- The post-threshold forbidden degrees: N + 2 × gaps(⟨3,5⟩) = {17, 19, 23, 29}. -/
def postThreshold_I : Finset ℕ := {17, 19, 23, 29}

/-- Post-threshold computation: 15 + 2·1 = 17, 15 + 2·2 = 19, 15 + 2·4 = 23, 15 + 2·7 = 29. -/
theorem postThreshold_computation :
    15 + 2 * 1 = 17 ∧ 15 + 2 * 2 = 19 ∧ 15 + 2 * 4 = 23 ∧ 15 + 2 * 7 = 29 := by
  constructor <;> [norm_num; constructor <;> [norm_num; constructor <;> norm_num]]

/-- The post-threshold set has 4 elements. -/
theorem postThreshold_I_count : postThreshold_I.card = 4 := by decide
